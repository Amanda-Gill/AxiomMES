# Axiom MES 智能生产系统 编程规范

**文档版本**：1.0  
**最后更新**：2026-02-23  
**适用范围**：Axiom MES 智能生产系统所有模块开发  
**状态**：正式发布  

---

## 目录

1. [引言](#1-引言)  
   1.1 [目的与范围](#11-目的与范围)  
   1.2 [技术栈总览](#12-技术栈总览)  
2. [通用编程规范](#2-通用编程规范)  
   2.1 [代码风格](#21-代码风格)  
   2.2 [命名约定](#22-命名约定)  
   2.3 [注释与文档](#23-注释与文档)  
   2.4 [版本控制](#24-版本控制)  
3. [后端开发规范（Python/FastAPI）](#3-后端开发规范pythonfastapi)  
   3.1 [项目结构](#31-项目结构)  
   3.2 [代码规范](#32-代码规范)  
   3.3 [API 设计规范](#33-api-设计规范)  
   3.4 [数据验证（Pydantic）](#34-数据验证pydantic)  
   3.5 [ORM 规范（SQLAlchemy）](#35-orm-规范sqlalchemy)  
   3.6 [任务队列（Celery）](#36-任务队列celery)  
   3.7 [工作流编排（Prefect）](#37-工作流编排prefect)  
   3.8 [规则引擎](#38-规则引擎)  
   3.9 [异常处理](#39-异常处理)  
   3.10 [日志规范](#310-日志规范)  
   3.11 [安全规范](#311-安全规范)  
4. [前端开发规范（Vue 3）](#4-前端开发规范vue-3)  
   4.1 [项目结构](#41-项目结构)  
   4.2 [代码风格与规范](#42-代码风格与规范)  
   4.3 [状态管理（Pinia）](#43-状态管理pinia)  
   4.4 [组件设计](#44-组件设计)  
   4.5 [API 请求规范](#45-api-请求规范)  
   4.6 [路由规范](#46-路由规范)  
   4.7 [样式规范](#47-样式规范)  
   4.8 [构建与打包](#48-构建与打包)  
5. [数据库规范](#5-数据库规范)  
   5.1 [通用原则](#51-通用原则)  
   5.2 [PostgreSQL 规范](#52-postgresql-规范)  
   5.3 [TimescaleDB 规范](#53-timescaledb-规范)  
   5.4 [MinIO 对象存储规范](#54-minio-对象存储规范)  
   5.5 [Elasticsearch 规范](#55-elasticsearch-规范)  
6. [消息队列规范（RabbitMQ）](#6-消息队列规范rabbitmq)  
   6.1 [队列命名与规划](#61-队列命名与规划)  
   6.2 [消息设计](#62-消息设计)  
   6.3 [生产者与消费者规范](#63-生产者与消费者规范)  
7. [缓存规范（Redis）](#7-缓存规范redis)  
   7.1 [缓存键设计](#71-缓存键设计)  
   7.2 [缓存策略](#72-缓存策略)  
   7.3 [分布式锁规范](#73-分布式锁规范)  
8. [监控与可观测性规范](#8-监控与可观测性规范)  
   8.1 [指标规范（Prometheus）](#81-指标规范prometheus)  
   8.2 [日志规范（Loki）](#82-日志规范loki)  
   8.3 [链路追踪规范（Tempo）](#83-链路追踪规范tempo)  
   8.4 [告警规范（Alertmanager）](#84-告警规范alertmanager)  
9. [安全规范](#9-安全规范)  
   9.1 [认证与授权](#91-认证与授权)  
   9.2 [数据传输安全](#92-数据传输安全)  
   9.3 [数据存储安全](#93-数据存储安全)  
   9.4 [输入校验与防注入](#94-输入校验与防注入)  
   9.5 [敏感信息保护](#95-敏感信息保护)  
10. [测试规范](#10-测试规范)  
    10.1 [单元测试](#101-单元测试)  
    10.2 [集成测试](#102-集成测试)  
    10.3 [性能测试](#103-性能测试)  
    10.4 [测试数据管理](#104-测试数据管理)  
11. [部署与运维规范](#11-部署与运维规范)  
    11.1 [容器化规范](#111-容器化规范)  
    11.2 [环境配置管理](#112-环境配置管理)  
    11.3 [CI/CD 规范](#113-cicd-规范)  
    11.4 [备份与恢复](#114-备份与恢复)  
12. [最佳实践与后期完善建议](#12-最佳实践与后期完善建议)  

---

## 1. 引言

### 1.1 目的与范围

本编程规范旨在为 Axiom MES 智能生产系统的开发团队提供统一的编码标准、项目结构指导、技术实践以及运维要求，确保系统的高质量、可维护性、可扩展性和安全性。所有参与本系统开发的工程师均应遵守本规范。

### 1.2 技术栈总览

- **后端**：Python 3.14, FastAPI 0.115.x, SQLAlchemy 2.0.x, Celery 5.5.x, Prefect 2.19.x, Rules Engine 1.x, Prometheus-client 0.21.x
- **前端**：Vue 3.4.x, Vite 5.x, Element Plus 2.x, Pinia 2.x, ECharts 5.x, Axios
- **数据库**：PostgreSQL 18, TimescaleDB 2.25.1, MinIO (对象存储), Elasticsearch 8.11.0 (可选)
- **消息队列**：RabbitMQ 3.13
- **缓存**：Redis 8.6.0
- **网关**：Traefik v3.6.8
- **监控**：Prometheus v3.9.1, Grafana 12.4.0, Loki 3.6.6, Tempo 2.9.1, Alertmanager v0.31.1
- **部署**：Docker, Docker Compose

---

## 2. 通用编程规范

### 2.1 代码风格

- **缩进**：统一使用 4 个空格，禁止使用制表符。
- **编码**：所有源文件必须使用 UTF-8 编码。
- **行长度**：不超过 120 个字符，超过时应合理换行。
- **空格**：运算符两侧、逗号后、冒号后（字典、切片等）应添加空格；函数定义、调用时括号内不加空格。
- **空行**：类定义之间空两行；方法定义之间空一行；不同逻辑块之间可适当空行分隔。

### 2.2 命名约定

| 类型 | 约定 | 示例 |
|------|------|------|
| 包/模块名 | 全小写，下划线分隔 | `auth`, `data_processor` |
| 类名 | 驼峰式（首字母大写） | `UserService`, `OrderController` |
| 函数/方法名 | 全小写，下划线分隔 | `get_user_by_id`, `calculate_cost` |
| 变量名 | 全小写，下划线分隔 | `user_list`, `total_count` |
| 常量 | 全大写，下划线分隔 | `MAX_RETRY_TIMES`, `DEFAULT_PAGE_SIZE` |
| 私有成员 | 下划线前缀 | `_internal_helper` |
| 环境变量 | 全大写，下划线分隔 | `DB_PASSWORD`, `REDIS_URL` |

### 2.3 注释与文档

- **文件头注释**：每个源文件开头应包含简要描述、作者、创建日期、修改记录。
- **文档字符串**：公共模块、类、方法必须编写 docstring，遵循 reStructuredText 或 Google 风格。
- **行内注释**：用于解释复杂的逻辑，避免显而易见的内容。
- **TODO/FIXME**：使用 `# TODO(作者): 说明` 或 `# FIXME(作者): 说明` 标记待办或需修复项。

### 2.4 版本控制

- **分支策略**：采用 Git Flow 或 Trunk Based 开发，主分支 `main` 为稳定版本，开发分支 `develop`，功能分支使用 `feature/` 前缀，修复分支使用 `hotfix/` 前缀。
- **提交信息**：遵循 [Conventional Commits](https://www.conventionalcommits.org/) 规范，如 `feat: 添加用户登录接口`、`fix: 修复空指针异常`。
- **Tag 管理**：每次发布需打版本 tag，格式 `v1.2.3`。

---

## 3. 后端开发规范（Python/FastAPI）

### 3.1 项目结构

遵循分层、模块化原则，推荐结构如下：

```
fastapi-project/
├── alembic/                 # 数据库迁移脚本
├── src/                     # 应用核心
│   ├── auth/                # 业务域：认证
│   │   ├── router.py        # 路由
│   │   ├── schemas.py       # Pydantic 模型
│   │   ├── models.py        # SQLAlchemy 模型
│   │   ├── service.py       # 业务逻辑
│   │   ├── dependencies.py  # 路由依赖
│   │   ├── constants.py     # 模块常量
│   │   ├── exceptions.py    # 模块异常
│   │   ├── utils.py         # 工具函数
│   │   └── tasks.py         # Celery 任务
│   ├── core/                # 通用核心层
│   │   ├── config.py        # 全局配置
│   │   ├── security.py      # 安全相关
│   │   ├── database.py      # 数据库连接
│   │   ├── logging.py       # 日志配置
│   │   ├── tasks/           # 通用 Celery 配置
│   │   ├── workflows/       # 通用 Prefect 配置
│   │   └── rules/           # 规则引擎核心
│   ├── utils/               # 全局工具
│   │   ├── pagination.py    # 分页
│   │   └── metrics.py       # 指标采集
│   └── main.py              # 应用入口
├── tests/                   # 测试
├── requirements/            # 依赖拆分
│   ├── base.txt
│   ├── dev.txt
│   └── prod.txt
├── .env                     # 环境变量
├── logging.ini              # 日志配置
└── alembic.ini              # 迁移配置
```

### 3.2 代码规范

- **类型注解**：所有函数参数和返回值必须使用类型注解。
- **导入顺序**：标准库 → 第三方库 → 本地模块，每组之间空一行，使用 `isort` 自动格式化。
- **PEP 8 合规**：使用 `flake8` 或 `pylint` 检查代码风格。

### 3.3 API 设计规范

- **RESTful 风格**：资源使用名词复数，如 `/users`，动作通过 HTTP 方法体现。
- **路径命名**：全小写，单词间用连字符 `-` 分隔（如 `/user-profiles`）。
- **版本控制**：在 URL 路径中包含版本号，如 `/api/v1/orders`。
- **请求与响应**：统一使用 JSON 格式，响应体包含 `code`、`message`、`data` 字段（或类似结构）。
- **状态码**：合理使用 HTTP 状态码（200、201、400、401、403、404、500 等）。
- **分页**：统一使用 `page` 和 `page_size` 参数，响应中包含总条数和分页信息。

### 3.4 数据验证（Pydantic）

- 每个模块的 `schemas.py` 中定义请求/响应模型。
- 使用 `Field` 描述字段约束（如 `min_length`、`max_length`、`regex`）。
- 配置 `Config` 类中的 `orm_mode = True` 以便与 ORM 模型互转。

### 3.5 ORM 规范（SQLAlchemy 2.0）

- **模型定义**：每个模块的 `models.py` 中定义，使用 `DeclarativeBase`。
- **命名**：表名使用小写加下划线，如 `user_account`；字段名也使用小写加下划线。
- **关系**：明确指定 `back_populates` 或 `backref`，并定义级联行为。
- **索引**：为经常查询的字段添加索引，组合索引合理使用。
- **迁移**：使用 Alembic 管理，每次模型变更需生成迁移脚本并 review。

### 3.6 任务队列（Celery）

- **任务定义**：任务函数放在模块的 `tasks.py` 中，使用 `@celery_app.task` 装饰。
- **任务命名**：使用点分隔的命名空间，如 `auth.send_welcome_email`。
- **队列规划**：根据优先级和业务类型分配到不同队列（`default`、`high_priority`、`strategy_execution`）。
- **结果处理**：启用任务结果存储（Redis），并设置合理的过期时间。
- **重试机制**：对可重试的任务配置 `retry_kwargs`（最大重试次数、重试延迟）。
- **任务超时**：设置 `time_limit` 和 `soft_time_limit` 防止任务卡死。

### 3.7 工作流编排（Prefect）

- **工作流定义**：放在模块的 `workflows.py` 中，使用 Prefect 的 `@flow` 和 `@task` 装饰器。
- **参数校验**：使用 Pydantic 校验 flow 参数。
- **日志**：利用 Prefect 内置日志记录关键步骤。
- **调度**：通过 Prefect 的调度功能或外部触发器启动工作流。

### 3.8 规则引擎

- **规则定义**：规则应集中管理，使用 JSON/YAML 格式存储，支持版本控制。
- **规则执行**：通过统一的规则引擎接口调用，避免业务代码中硬编码逻辑。
- **性能**：规则引擎执行应异步化或缓存，避免阻塞主流程。

### 3.9 异常处理

- **自定义异常**：每个模块定义自己的异常类，继承自 `HTTPException` 或 `Exception`。
- **全局异常处理**：在 `main.py` 中注册全局异常处理器，统一返回错误响应。
- **日志记录**：捕获异常时记录完整堆栈（使用 `logger.exception`）。

### 3.10 日志规范

- **日志级别**：DEBUG（开发调试）、INFO（关键流程）、WARNING（潜在问题）、ERROR（可恢复错误）、CRITICAL（系统不可用）。
- **日志格式**：JSON 格式，包含时间、级别、模块、请求 ID、用户 ID、消息等字段，便于 Loki 收集。
- **请求 ID 透传**：使用 `middleware` 为每个请求生成唯一 `request_id`，并在日志和上下游服务中传递。

### 3.11 安全规范

- **认证**：使用 OAuth2 + JWT，令牌中不包含敏感信息，过期时间合理。
- **授权**：基于 RBAC 的权限控制，在路由依赖中检查权限。
- **限流**：使用 `fastapi-limiter` 对接口进行限流，防止暴力攻击。
- **密码存储**：使用 `passlib` 的 `bcrypt` 算法哈希存储。
- **敏感数据脱敏**：日志和响应中过滤手机号、身份证等敏感字段。

---

## 4. 前端开发规范（Vue 3）

### 4.1 项目结构

```
frontend/
├── public/                 # 静态资源
├── src/
│   ├── assets/             # 图片、字体等
│   ├── components/         # 公共组件
│   ├── views/              # 页面组件
│   ├── stores/             # Pinia 状态管理
│   ├── router/             # 路由配置
│   ├── api/                # API 接口
│   ├── utils/              # 工具函数
│   ├── styles/             # 全局样式
│   ├── App.vue             # 根组件
│   └── main.ts             # 入口
├── package.json
├── vite.config.ts
└── tsconfig.json
```

### 4.2 代码风格与规范

- **语言**：使用 TypeScript，严格模式。
- **组件**：使用 `<script setup>` 语法组合式 API。
- **命名**：组件文件使用 PascalCase（如 `UserProfile.vue`），组件名与文件名一致。
- **Props 定义**：使用 `defineProps<Type>()` 并指定类型。
- **Emits 定义**：使用 `defineEmits` 并定义事件名称和参数类型。
- **代码格式化**：使用 Prettier 统一风格，ESLint 检查。

### 4.3 状态管理（Pinia）

- **Store 定义**：每个模块一个 store，使用 `defineStore`。
- **状态**：只读状态使用 `ref` 或 `reactive`，修改通过 actions。
- **Getter**：使用 `computed` 派生状态。
- **持久化**：根据需要可集成 pinia-plugin-persistedstate。

### 4.4 组件设计

- **单一职责**：每个组件只负责一块功能，复杂页面拆分为多个子组件。
- **通信**：父子组件通过 props/emits，跨层级使用 provide/inject 或 Pinia。
- **复用**：公共组件放在 `components/` 下，且应有完善的 props 类型定义和文档。

### 4.5 API 请求规范

- **统一实例**：使用 axios 创建实例，配置 baseURL、超时、拦截器。
- **请求拦截**：自动添加 token。
- **响应拦截**：统一处理错误码，如 401 跳转登录。
- **接口定义**：在 `api/` 目录下按模块组织，每个接口返回 Promise 类型。

### 4.6 路由规范

- **路由配置**：使用 Vue Router，路由 path 使用 kebab-case。
- **懒加载**：使用 `import()` 实现路由懒加载。
- **权限控制**：通过路由守卫检查用户权限，动态添加路由。

### 4.7 样式规范

- **作用域**：组件内样式使用 `<style scoped>`，避免全局污染。
- **预处理器**：使用 SCSS 或 CSS 变量管理主题。
- **类名命名**：使用 BEM 或 utility-first（如 Tailwind CSS，但需团队统一）。
- **响应式**：使用 ECharts 大屏自适应方案，页面适配不同屏幕。

### 4.8 构建与打包

- **构建工具**：Vite，配置别名 `@` 指向 `src`。
- **环境变量**：使用 `.env` 文件管理，变量名以 `VITE_` 开头。
- **打包优化**：开启代码分割、压缩、移除 console。

---

## 5. 数据库规范

### 5.1 通用原则

- **字符集**：使用 UTF-8。
- **命名**：表名、字段名使用小写加下划线，避免使用保留字。
- **主键**：推荐使用自增整数或雪花算法生成的分布式 ID（如 `id BIGSERIAL PRIMARY KEY`）。
- **外键**：尽量避免使用物理外键，由应用层保证数据一致性；若使用需明确级联规则。
- **索引**：为查询条件、排序、关联字段建立索引，避免过多索引影响写入性能。

### 5.2 PostgreSQL 规范

- **连接池**：应用层使用连接池（如 SQLAlchemy 的池），设置合理的大小。
- **事务**：保持事务尽可能短，避免长事务。
- **VACUUM**：定期执行 VACUUM 或启用 autovacuum。
- **分区**：大表（如日志）使用表分区（按时间）。
- **备份**：每日全量 + 增量备份，备份文件加密。

### 5.3 TimescaleDB 规范

- **超表**：时序数据必须创建为超表，按时间分区。
- **数据压缩**：启用压缩策略，减少存储。
- **连续聚合**：对常用统计创建连续聚合视图，提升查询性能。
- **保留策略**：设置数据保留时间，自动删除过期数据。

### 5.4 MinIO 对象存储规范

- **桶命名**：全小写，点分隔，如 `mes.strategy.files`。
- **权限**：使用 IAM 策略控制桶和对象访问，最小权限原则。
- **加密**：启用服务端加密（SSE-S3）。
- **版本控制**：对重要文件启用版本控制，防止误删。
- **生命周期**：设置生命周期规则，自动转移或删除过期文件。

### 5.5 Elasticsearch 规范

- **索引命名**：全小写，多个单词用下划线分隔，如 `mes_audit_log_202602`。
- **映射**：预先定义索引映射，避免动态映射导致类型错误。
- **分片**：根据数据量设置分片数，避免过多分片。
- **备份**：定期快照备份到对象存储。

---

## 6. 消息队列规范（RabbitMQ）

### 6.1 队列命名与规划

- **队列命名**：`<业务>.<用途>[.<优先级>]`，如 `order.created`、`strategy.execute.high`。
- **交换机**：使用 topic 交换机，便于灵活路由。
- **队列属性**：持久化队列，消息持久化，避免数据丢失。
- **死信队列**：为重要队列配置死信交换机，处理消费失败的消息。

### 6.2 消息设计

- **消息体**：JSON 格式，包含消息 ID、时间戳、业务数据等。
- **幂等性**：消费者需实现幂等处理（通过业务 ID 去重）。
- **消息大小**：避免过大的消息，超过建议压缩或拆分。

### 6.3 生产者与消费者规范

- **生产者**：发送消息时设置 `delivery_mode=2` 确保持久化，可配置确认机制。
- **消费者**：手动确认消息（basic_ack），处理失败时根据业务决定重入队列或进入死信。
- **并发**：根据队列重要性设置合理的消费者数量，避免消息堆积。

---

## 7. 缓存规范（Redis）

### 7.1 缓存键设计

- **键格式**：`<业务>:[<模块>:]<键名>[:<子键>]`，如 `user:profile:123`，`cache:api:/orders`。
- **命名空间**：使用冒号分隔，便于管理和删除。
- **过期时间**：必须设置合理的 TTL，防止内存无限增长。

### 7.2 缓存策略

- **缓存模式**：常用模式为 Cache-Aside（读时回填，写时失效）。
- **更新策略**：数据变更时主动删除或更新缓存，保持一致性。
- **预热**：系统启动时可对热点数据进行预热。

### 7.3 分布式锁规范

- **锁实现**：使用 Redlock 算法（或 Redis 单节点 + SET NX PX），确保锁的可靠性。
- **锁键**：格式 `lock:<资源>`，如 `lock:order:123`。
- **超时**：设置合理的锁超时时间，防止死锁。
- **释放**：必须校验锁持有者，只释放自己持有的锁。

---

## 8. 监控与可观测性规范

### 8.1 指标规范（Prometheus）

- **指标命名**：使用下划线分隔，如 `http_requests_total`、`celery_tasks_failed_total`。
- **标签**：添加必要标签（如 endpoint、method、status），避免标签值过多。
- **业务指标**：暴露关键业务指标（订单量、策略执行次数等）。
- **采集**：应用层通过 Prometheus-client 暴露 `/metrics` 端点。

### 8.2 日志规范（Loki）

- **日志采集**：所有容器日志由 Promtail 采集并发送至 Loki。
- **日志标签**：添加服务名、容器名、级别等标签，便于检索。
- **结构化日志**：推荐 JSON 格式，包含 timestamp、level、service、request_id、message 等字段。

### 8.3 链路追踪规范（Tempo）

- **Trace 透传**：前端请求携带 trace ID，后端服务之间通过 HTTP 头（如 `uber-trace-id`）传递。
- **采样**：根据流量配置合理的采样率（如头采样或概率采样）。
- **Span 命名**：使用 `<service>.<operation>`，如 `auth.authenticate`。

### 8.4 告警规范（Alertmanager）

- **告警规则**：在 Prometheus 中定义，规则清晰，避免噪音。
- **分组与抑制**：配置合理的分组和抑制规则，防止告警风暴。
- **通知渠道**：集成钉钉、企业微信、邮件等，确保及时响应。

---

## 9. 安全规范

### 9.1 认证与授权

- **认证**：使用 OAuth2 密码模式（或授权码模式）获取 JWT，JWT 有效期短，使用刷新令牌。
- **授权**：基于角色的访问控制（RBAC），权限数据存储在数据库，通过中间件校验。
- **API 密钥**：服务间通信可使用 API 密钥或 mTLS。

### 9.2 数据传输安全

- **HTTPS**：全站强制 HTTPS，Traefik 自动管理 Let's Encrypt 证书。
- **HSTS**：启用 HTTP Strict Transport Security。
- **内部通信**：关键服务间启用 TLS 或 mTLS。

### 9.3 数据存储安全

- **敏感数据加密**：数据库中的敏感字段（如密码、密钥）加密存储。
- **备份加密**：所有备份文件必须加密。

### 9.4 输入校验与防注入

- **输入校验**：后端使用 Pydantic 严格校验请求数据，防止注入。
- **SQL 注入**：使用 ORM 参数化查询，避免拼接 SQL。
- **XSS 防护**：前端输出时转义，后端设置 CSP 头。

### 9.5 敏感信息保护

- **日志脱敏**：在日志输出前过滤身份证、手机号、令牌等敏感信息。
- **配置管理**：密钥、密码等通过环境变量或 Vault 管理，禁止硬编码。

---

## 10. 测试规范

### 10.1 单元测试

- **框架**：pytest（后端），Vitest（前端）。
- **覆盖率**：核心模块行覆盖率不低于 80%。
- **Mock**：外部依赖（数据库、缓存、消息队列）使用 mock 或 Testcontainers。

### 10.2 集成测试

- **环境**：使用 Docker Compose 启动所有依赖服务，运行测试。
- **API 测试**：对每个接口编写测试用例，覆盖正常和异常场景。
- **数据清理**：测试前后清理测试数据，保证隔离性。

### 10.3 性能测试

- **工具**：Locust 或 JMeter 模拟高并发。
- **场景**：核心接口（如策略执行、订单处理）需进行压力测试，确定系统瓶颈。
- **指标**：关注响应时间、吞吐量、错误率、CPU/内存使用。

### 10.4 测试数据管理

- **数据准备**：使用 fixture 或工厂函数生成测试数据。
- **数据版本**：测试数据随代码版本管理，确保可重现。

---

## 11. 部署与运维规范

### 11.1 容器化规范

- **基础镜像**：使用官方 slim 或 alpine 镜像，减小体积。
- **Dockerfile**：多阶段构建，最终镜像只包含运行所需文件。
- **健康检查**：为每个服务定义 HEALTHCHECK。
- **资源限制**：在 Docker Compose 或 Kubernetes 中设置 CPU/内存 limits 和 requests。

### 11.2 环境配置管理

- **环境分离**：开发、测试、生产使用独立的配置文件/环境变量。
- **配置中心**：建议引入 Consul 或 Apollo 管理配置，支持动态刷新。
- **密钥管理**：使用 HashiCorp Vault 或云 KMS 管理敏感信息。

### 11.3 CI/CD 规范

- **CI 流程**：代码提交触发自动化测试（单元测试、代码扫描、构建镜像）。
- **CD 流程**：测试通过后自动部署到测试环境，手动触发生产发布。
- **版本标签**：镜像标签使用 Git commit hash 或语义版本。

### 11.4 备份与恢复

- **备份策略**：数据库每日全量，WAL 归档；对象存储实时复制；配置文件 Git 版本控制。
- **恢复演练**：每季度至少一次恢复演练，验证 RPO/RTO。
- **异地备份**：关键数据备份到异地存储或云。

---

## 12. 最佳实践与后期完善建议

- **配置中心**：引入 Apollo/Nacos 统一管理配置，支持动态刷新。
- **数据读写分离**：为 PostgreSQL 配置主从复制，读流量分发到从库。
- **分库分表**：对订单、日志等大表提前规划分库分表策略。
- **全链路追踪增强**：确保所有组件（前端、网关、后端、消息队列）都透传 Trace ID。
- **性能剖析**：集成 Pyroscope 进行持续性能剖析。
- **零信任网络**：服务间启用 mTLS，使用服务网格（如 Istio）加强安全。
- **成本优化**：定期分析资源使用，回收低负载实例，设置数据生命周期管理。

---

**文档维护**：Axiom MES 架构组  
**联系方式**：363679401@qq.com  
**更新记录**：  
- v1.0，2026-02-23，初始版本发布。